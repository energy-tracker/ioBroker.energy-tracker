{
  "version": 3,
  "sources": ["../../src/lib/device-scheduler.spec.ts"],
  "sourcesContent": ["import { expect } from \"chai\";\nimport sinon from \"sinon\";\nimport { DeviceScheduler } from \"./device-scheduler\";\nimport { EnergyTrackerApi } from \"./energy-tracker-api\";\n\ndescribe(\"DeviceScheduler\", () => {\n  let adapterMock: sinon.SinonStubbedInstance<ioBroker.Adapter>;\n  let apiMock: sinon.SinonStubbedInstance<EnergyTrackerApi>;\n  let scheduler: DeviceScheduler;\n\n  beforeEach(() => {\n    adapterMock = {\n      log: {\n        info: sinon.stub(),\n        warn: sinon.stub(),\n      },\n    } as unknown as sinon.SinonStubbedInstance<ioBroker.Adapter>;\n\n    apiMock = {\n      sendReading: sinon.stub().resolves(),\n    } as unknown as sinon.SinonStubbedInstance<EnergyTrackerApi>;\n\n    scheduler = new DeviceScheduler(adapterMock, apiMock);\n  });\n\n  afterEach(() => {\n    scheduler.clear();\n    sinon.restore();\n  });\n\n  it(\"should schedule reading tasks for devices\", () => {\n    // Arrange\n    const devices = [\n      { deviceId: \"id1\", sourceState: \"state1\", sendIntervalHours: 0.0001, allowRounding: true },\n      { deviceId: \"id2\", sourceState: \"state2\", sendIntervalHours: 0.0001, allowRounding: true },\n    ] satisfies ioBroker.AdapterDevice[];\n\n    // Act\n    scheduler.schedule(devices);\n\n    // Assert\n    expect((apiMock.sendReading as sinon.SinonStub).callCount).to.equal(2);\n    expect(scheduler.timerCount).to.equal(2);\n  });\n\n  it(\"should skip invalid devices without deviceId or sourceState\", () => {\n    // Arrange\n    const devices = [\n      { deviceId: \"\", sourceState: \"state1\", sendIntervalHours: 1, allowRounding: true },\n      { deviceId: \"id2\", sourceState: \"\", sendIntervalHours: 1, allowRounding: true },\n    ] satisfies ioBroker.AdapterDevice[];\n\n    // Act\n    scheduler.schedule(devices);\n\n    // Assert\n    expect((apiMock.sendReading as sinon.SinonStub).callCount).to.equal(0);\n    expect(scheduler.timerCount).to.equal(0);\n  });\n\n  it(\"should clear all timers when clear() is called\", () => {\n    // Arrange\n    const devices = [\n      { deviceId: \"id1\", sourceState: \"state1\", sendIntervalHours: 1, allowRounding: true },\n    ] satisfies ioBroker.AdapterDevice[];\n    scheduler.schedule(devices);\n\n    // Act\n    scheduler.clear();\n\n    // Assert\n    expect(scheduler.timerCount).to.equal(0);\n  });\n});\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA,kBAAuB;AACvB,mBAAkB;AAClB,8BAAgC;AAGhC,SAAS,mBAAmB,MAAM;AAChC,MAAI;AACJ,MAAI;AACJ,MAAI;AAEJ,aAAW,MAAM;AACf,kBAAc;AAAA,MACZ,KAAK;AAAA,QACH,MAAM,aAAAA,QAAM,KAAK;AAAA,QACjB,MAAM,aAAAA,QAAM,KAAK;AAAA,MACnB;AAAA,IACF;AAEA,cAAU;AAAA,MACR,aAAa,aAAAA,QAAM,KAAK,EAAE,SAAS;AAAA,IACrC;AAEA,gBAAY,IAAI,wCAAgB,aAAa,OAAO;AAAA,EACtD,CAAC;AAED,YAAU,MAAM;AACd,cAAU,MAAM;AAChB,iBAAAA,QAAM,QAAQ;AAAA,EAChB,CAAC;AAED,KAAG,6CAA6C,MAAM;AAEpD,UAAM,UAAU;AAAA,MACd,EAAE,UAAU,OAAO,aAAa,UAAU,mBAAmB,MAAQ,eAAe,KAAK;AAAA,MACzF,EAAE,UAAU,OAAO,aAAa,UAAU,mBAAmB,MAAQ,eAAe,KAAK;AAAA,IAC3F;AAGA,cAAU,SAAS,OAAO;AAG1B,4BAAQ,QAAQ,YAAgC,SAAS,EAAE,GAAG,MAAM,CAAC;AACrE,4BAAO,UAAU,UAAU,EAAE,GAAG,MAAM,CAAC;AAAA,EACzC,CAAC;AAED,KAAG,+DAA+D,MAAM;AAEtE,UAAM,UAAU;AAAA,MACd,EAAE,UAAU,IAAI,aAAa,UAAU,mBAAmB,GAAG,eAAe,KAAK;AAAA,MACjF,EAAE,UAAU,OAAO,aAAa,IAAI,mBAAmB,GAAG,eAAe,KAAK;AAAA,IAChF;AAGA,cAAU,SAAS,OAAO;AAG1B,4BAAQ,QAAQ,YAAgC,SAAS,EAAE,GAAG,MAAM,CAAC;AACrE,4BAAO,UAAU,UAAU,EAAE,GAAG,MAAM,CAAC;AAAA,EACzC,CAAC;AAED,KAAG,kDAAkD,MAAM;AAEzD,UAAM,UAAU;AAAA,MACd,EAAE,UAAU,OAAO,aAAa,UAAU,mBAAmB,GAAG,eAAe,KAAK;AAAA,IACtF;AACA,cAAU,SAAS,OAAO;AAG1B,cAAU,MAAM;AAGhB,4BAAO,UAAU,UAAU,EAAE,GAAG,MAAM,CAAC;AAAA,EACzC,CAAC;AACH,CAAC;",
  "names": ["sinon"]
}
